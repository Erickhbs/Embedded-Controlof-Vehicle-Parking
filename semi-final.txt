/**
 * @file mqtt_flutter_parking.ino
 * @author Erick Henrique Barros da Silva
 * @brief Controlador Embarcado de Estacionamento de Veículos baseado em FreeRTOS e Flutter.
 * @date 2025-06-21 -- ultima modificação
 *
 * @details Este projeto implementa um sistema de controle de estacionamento inteligente.
 * O ESP32 monitora o estado das vagas (livre, ocupada, reservada) usando sensores
 * e se comunica em tempo real com um aplicativo móvel (Flutter) através da mensageria MQTT.
 * O estado do sistema é persistido no Firebase Realtime Database para garantir a
 * recuperação de dados em caso de reinicialização ou falha de energia.
 * O sistema operacional de tempo real FreeRTOS é utilizado para gerenciar as múltiplas
 * tarefas de forma concorrente e eficiente.
 */

// =================================================================
// INCLUSÃO DE BIBLIOTECAS
// =================================================================
#include <WiFi.h>             // Para conectar o ESP32 à rede Wi-Fi.
#include <PubSubClient.h>     // Cliente MQTT para comunicação com o broker.
#include <ESP32Servo.h>       // Controle de servomotores no ESP32.
#include <ArduinoJson.h>      // Para manipular (serializar/desserializar) objetos JSON.
#include <freertos/FreeRTOS.h> // Biblioteca principal do sistema operacional de tempo real.
#include <freertos/task.h>     // Para criação e gerenciamento de tarefas.
#include <Firebase_ESP_Client.h> // Biblioteca para comunicação com o Firebase.
#include <addons/TokenHelper.h>  // Funções auxiliares para autenticação no Firebase.
#include <addons/RTDBHelper.h>   // Funções auxiliares para o Realtime Database.

// =================================================================
// DEFINIÇÕES E CONFIGURAÇÕES GLOBAIS
// =================================================================

// --- Credenciais de Rede ---
#define WIFI_SSID "batata"
#define WIFI_PASSWORD "123456789"

// --- Credenciais do Firebase ---
#define API_KEY "AIzaSyCSsv-ZCRFAF4LvFjowihWr5ITkPEdz7YA"
#define USER_EMAIL "parking_esp32@iot.com"
#define USER_PASSWORD "123456789"
#define DATABASE_URL "https://parking-mqtt-flutter-default-rtdb.firebaseio.com"

// --- Configurações do Broker MQTT ---
const char* mqtt_server = "test.mosquitto.org";
const int mqtt_port = 1883;

// --- Constantes do Projeto ---
const int TOTAL_VAGAS = 4;
const int TOTAL_CATRACAS = 2;

// =================================================================
// STRUCTS E ENUMS
// =================================================================
// Enum para definir a função de uma catraca, melhorando a legibilidade do código.
enum RoleCatraca { ENTRADA, SAIDA };

// Struct para armazenar coordenadas, útil para mapeamento no app.
struct Coordenada {
  double x, y;
};

// Struct para representar uma catraca, agrupando todas as suas propriedades.
struct Catraca {
  String id;
  Coordenada coordenada;
  RoleCatraca role;
  byte pinoServo;
  Servo servo; // Cada catraca tem seu próprio objeto Servo.
};

// Struct para representar uma vaga, agrupando estado e pinos de hardware.
struct Vaga {
  String id;
  bool ocupada;
  bool reservada;
  byte pinoSensor;
  byte pinoLedVermelho; // LED para indicar vaga ocupada.
  byte pinoLedRgbG;     // Pino Verde do LED RGB (Anodo Comum).
  byte pinoLedRgbB;     // Pino Azul do LED RGB (Anodo Comum).
  Coordenada coordenada;
};

// =================================================================
// VARIÁVEIS GLOBAIS E INSTÂNCIAS DE OBJETOS
// =================================================================

// --- Instâncias de Hardware e Rede ---
WiFiClient espClient;
PubSubClient client(espClient);

// --- Instâncias do Firebase ---
FirebaseData fbdo;
FirebaseAuth auth;
FirebaseConfig config;

// --- Definição do Hardware do Estacionamento ---
Catraca catracas = {
  {"C1", {0.0, 0.0}, ENTRADA, 23},
  {"C3", {0.0, 1.0}, SAIDA, 21}
};

Vaga vagas = {
  {"V1", false, false, 27, 35, 12, 13, {0, 0}},
  {"V2", false, false, 26, 32, 14, 15, {1, 0}},
  {"V3", false, false, 25, 5, 17, 19, {0, 1}},
  {"V4", false, false, 33, 18, 20, 24, {1, 1}}
};

// --- Variáveis de Controle de Estado ---
int vagasDisponiveis = TOTAL_VAGAS;
bool estadoAlterado = true; // Flag para otimizar publicações: só publica quando algo muda.
volatile String comandoAbrirCatraca = ""; // Variável para comunicação entre tasks (MQTT -> Controle Catraca)

// --- Primitivas do FreeRTOS ---
SemaphoreHandle_t vagasMutex; // Mutex para garantir acesso seguro aos dados compartilhados das vagas.

// Forward declarations para o compilador saber que as funções existem.
void publicarEstado();
void reconnect();

// =================================================================
// FUNÇÕES DE LÓGICA DE NEGÓCIO
// =================================================================

/**
 * @brief Calcula o número de vagas disponíveis.
 * Esta função é a única fonte da verdade para a contagem,
 * garantindo consistência em todo o sistema.
 */
void atualizarContagemVagas() {
  int ocupadasOuReservadas = 0;
  for (int i = 0; i < TOTAL_VAGAS; i++) {
    if (vagas[i].ocupada |
| vagas[i].reservada) {
      ocupadasOuReservadas++;
    }
  }
  vagasDisponiveis = TOTAL_VAGAS - ocupadasOuReservadas;
  estadoAlterado = true; // Sinaliza que o estado mudou e precisa ser publicado.
}

/**
 * @brief Controla os LEDs de cada vaga com base no seu estado.
 * A lógica é ajustada para um LED vermelho separado e um LED RGB de Anodo Comum.
 * Em Anodo Comum, o pino comum é ligado ao VCC (HIGH) e para acender uma cor,
 * o pino correspondente é colocado em LOW.
 */
void controlarLEDs() {
  for (int i = 0; i < TOTAL_VAGAS; i++) {
    if (vagas[i].ocupada) {
      // Estado OCUPADA: Acende LED vermelho, apaga RGB.
      digitalWrite(vagas[i].pinoLedVermelho, HIGH);
      digitalWrite(vagas[i].pinoLedRgbG, HIGH); // Apaga verde
      digitalWrite(vagas[i].pinoLedRgbB, HIGH); // Apaga azul
    } else if (vagas[i].reservada) {
      // Estado RESERVADA: Acende LED azul do RGB, apaga os outros.
      digitalWrite(vagas[i].pinoLedVermelho, LOW);
      digitalWrite(vagas[i].pinoLedRgbG, HIGH); // Apaga verde
      digitalWrite(vagas[i].pinoLedRgbB, LOW);  // Acende azul
    } else {
      // Estado LIVRE: Acende LED verde do RGB, apaga os outros.
      digitalWrite(vagas[i].pinoLedVermelho, LOW);
      digitalWrite(vagas[i].pinoLedRgbG, LOW);  // Acende verde
      digitalWrite(vagas[i].pinoLedRgbB, HIGH); // Apaga azul
    }
  }
}

// =================================================================
// TAREFAS DO FREERTOS
// =================================================================

/**
 * @brief Tarefa que lê continuamente os sensores das vagas.
 * @details Esta tarefa é o coração da detecção de veículos. Ela atualiza o estado
 * de ocupação das vagas e a lógica de reserva. É fixada no Core 0 para garantir
 * resposta rápida e não ser afetada por tarefas de rede.
 * @param pvParameters Parâmetros da tarefa (não utilizado).
 */
void taskLerSensores(void *pvParameters) {
  while (true) {
    // Protege o acesso ao array 'vagas' com o mutex.
    if (xSemaphoreTake(vagasMutex, portMAX_DELAY) == pdTRUE) {
      for (int i = 0; i < TOTAL_VAGAS; i++) {
        // Lê o sensor. A lógica `!` é usada pois INPUT_PULLUP faz o pino ser HIGH quando livre.
        bool estadoAtual =!digitalRead(vagas[i].pinoSensor);

        // Se o estado do sensor mudou, atualiza a lógica.
        if (estadoAtual!= vagas[i].ocupada) {
          vagas[i].ocupada = estadoAtual;
          // Se um carro ocupou uma vaga que estava reservada, a reserva é consumida.
          if (estadoAtual && vagas[i].reservada) {
            vagas[i].reservada = false;
          }
          // Se um carro saiu, a vaga não pode mais estar reservada.
          if (!estadoAtual) {
            vagas[i].reservada = false;
          }
          atualizarContagemVagas(); // Recalcula vagas e sinaliza para publicação.
        }
      }
      // Libera o mutex para que outras tarefas possam usar os dados.
      xSemaphoreGive(vagasMutex);
    }

    controlarLEDs(); // Atualiza o estado visual dos LEDs.
    vTaskDelay(500 / portTICK_PERIOD_MS); // Pausa a tarefa por 500ms para não sobrecarregar a CPU.
  }
}

/**
 * @brief Tarefa que processa comandos de abertura de catraca.
 * @details Esta tarefa desacopla o controle do servo da recepção de mensagens MQTT.
 * Ela fica verificando se há um novo comando e o executa, evitando bloquear
 * a tarefa de rede, o que torna o sistema mais estável.
 * @param pvParameters Parâmetros da tarefa (não utilizado).
 */
void taskControleCatracas(void *pvParameters) {
  while (true) {
    String idCatracaLocal = ""; // Cópia local para trabalhar de forma segura.

    // --- Seção Crítica: Acessa a variável global 'comandoAbrirCatraca' ---
    // Protege o acesso com o mutex para evitar condições de corrida.
    if (xSemaphoreTake(vagasMutex, (TickType_t)10) == pdTRUE) {
      if (comandoAbrirCatraca!= "") {
        idCatracaLocal = comandoAbrirCatraca; // Copia o comando para a variável local.
        comandoAbrirCatraca = "";             // Limpa a variável global para não processar de novo.
      }
      xSemaphoreGive(vagasMutex);
    }
    // --- Fim da Seção Crítica ---

    // Se um comando foi copiado, processa-o.
    if (idCatracaLocal!= "") {
      if (xSemaphoreTake(vagasMutex, portMAX_DELAY) == pdTRUE) {
        for (int i = 0; i < TOTAL_CATRACAS; i++) {
          if (catracas[i].id == idCatracaLocal) {
            bool podeAbrir = ((catracas[i].role == ENTRADA && vagasDisponiveis > 0) |
| catracas[i].role == SAIDA);
            if (podeAbrir) {
              catracas[i].servo.write(90);
              vTaskDelay(3000 / portTICK_PERIOD_MS); // Mantém aberta por 3s.
              catracas[i].servo.write(0);
            }
            break; // Sai do loop pois já encontrou a catraca.
          }
        }
        xSemaphoreGive(vagasMutex); // Libera o mutex.
      }
    }
    vTaskDelay(100 / portTICK_PERIOD_MS); // Verifica por novos comandos a cada 100ms.
  }
}

/**
 * @brief Tarefa que gerencia a conexão e o loop do cliente MQTT.
 * @details Mantém a conexão com o broker MQTT e publica o estado do sistema
 * sempre que a flag `estadoAlterado` for verdadeira. Fixada no Core 1,
 * dedicado a tarefas de comunicação de rede.
 * @param pvParameters Parâmetros da tarefa (não utilizado).
 */
void taskMQTT(void *pvParameters) {
  while (true) {
    if (!client.connected()) {
      reconnect();
    }
    client.loop(); // Essencial para processar mensagens recebidas e manter a conexão.

    if (estadoAlterado) {
      publicarEstado();
      estadoAlterado = false; // Reseta a flag após a publicação.
    }
    vTaskDelay(500 / portTICK_PERIOD_MS); // Pausa para economizar CPU.
  }
}

// =================================================================
// FUNÇÕES DE CALLBACK E SETUP
// =================================================================

/**
 * @brief Função de callback, chamada sempre que uma mensagem chega em um tópico assinado.
 * @details Processa os comandos JSON vindos do app Flutter.
 * A lógica aqui é rápida e não-bloqueante para não travar o cliente MQTT.
 */
void callback(char* topic, byte* payload, unsigned int length) {
  // Otimização de memória: buffer menor, apenas o necessário para comandos.
  StaticJsonDocument doc;
  deserializeJson(doc, payload, length);

  // Protege o acesso ao array 'vagas' com o mutex.
  if (xSemaphoreTake(vagasMutex, portMAX_DELAY) == pdTRUE) {
    if (doc.containsKey("reservar_vaga")) {
      String id = doc["reservar_vaga"];
      bool reservar = doc["estado"];
      for (int i = 0; i < TOTAL_VAGAS; i++) {
        // Só permite reservar uma vaga se ela estiver totalmente livre.
        if (vagas[i].id == id && reservar &&!vagas[i].ocupada &&!vagas[i].reservada) {
          vagas[i].reservada = true;
          atualizarContagemVagas();
          break; // Sai do loop após encontrar e reservar a vaga.
        }
      }
    }
    xSemaphoreGive(vagasMutex); // Libera o mutex.
  }

  if (doc.containsKey("abrir_catraca")) {
    // Apenas sinaliza para a outra tarefa qual catraca abrir. Não bloqueia aqui.
    if (xSemaphoreTake(vagasMutex, portMAX_DELAY) == pdTRUE) {
      comandoAbrirCatraca = doc["abrir_catraca"].as<String>();
      xSemaphoreGive(vagasMutex);
    }
  }
}

/**
 * @brief Configura e conecta o ESP32 à rede Wi-Fi.
 */
void setup_wifi() {
  Serial.print("Conectando ao WiFi...");
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
  while (WiFi.status()!= WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("\nWiFi conectado: " + WiFi.localIP().toString());
}

/**
 * @brief Configura e inicializa a conexão com o Firebase.
 */
void setup_firebase() {
  Serial.print("Inicializando Firebase...");
  config.api_key = API_KEY;
  config.database_url = DATABASE_URL;
  auth.user.email = USER_EMAIL;
  auth.user.password = USER_PASSWORD;

  // Associa a função de callback para o status do token (necessário pela biblioteca).
  config.token_status_callback = tokenStatusCallback;

  Firebase.begin(&config, &auth);
  Firebase.reconnectWiFi(true);

  // Espera até que a autenticação com o Firebase esteja completa.
  while (!Firebase.ready()) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("\nFirebase pronto!");
}

/**
 * @brief Tenta reconectar ao broker MQTT em caso de queda de conexão.
 */
void reconnect() {
  while (!client.connected()) {
    Serial.print("Tentando conectar ao MQTT...");
    if (client.connect("ESP32_ParkingClient")) {
      Serial.println(" conectado!");
      // Assina o tópico de comandos onde o app Flutter irá publicar.
      client.subscribe("parking/commands");
    } else {
      Serial.print(" falhou, rc=");
      Serial.print(client.state());
      Serial.println(" tentando novamente em 5 segundos");
      delay(5000);
    }
  }
}

/**
 * @brief Publica o estado atual do estacionamento para o MQTT e Firebase.
 */
void publicarEstado() {
  // Otimização de memória: buffer com tamanho ajustado para os dados.
  StaticJsonDocument doc;

  // Protege a leitura dos dados das vagas com o mutex.
  if (xSemaphoreTake(vagasMutex, portMAX_DELAY) == pdTRUE) {
    doc["vagas_disponiveis"] = vagasDisponiveis;
    JsonArray vagasStatus = doc.createNestedArray("vagas");
    for (int i = 0; i < TOTAL_VAGAS; i++) {
      JsonObject o = vagasStatus.createNestedObject();
      o["id"] = vagas[i].id;
      o["ocupada"] = vagas[i].ocupada;
      o["reservada"] = vagas[i].reservada;
    }
    xSemaphoreGive(vagasMutex); // Libera o mutex.
  }

  String json;
  serializeJson(doc, json);

  // Publica para o tópico de status do MQTT.
  client.publish("parking/status", json.c_str());

  // Salva o mesmo JSON no Firebase como backup.
  if (Firebase.ready()) {
    Firebase.RTDB.setString(&fbdo, "/parking_status", json);
  }
  Serial.println("Estado publicado.");
}

/**
 * @brief Restaura o último estado salvo no Firebase ao iniciar.
 * @details Essencial para a resiliência do sistema contra falhas de energia.
 */
void restaurarEstadoDoFirebase() {
  Serial.println("Restaurando estado do Firebase...");
  if (Firebase.ready() && Firebase.RTDB.getString(&fbdo, "/parking_status")) {
    String json = fbdo.stringData();
    StaticJsonDocument doc; // Usa o mesmo tamanho do buffer de publicação.
    if (deserializeJson(doc, json) == DeserializationError::Ok) {
      // Protege a escrita no array 'vagas' com o mutex.
      if (xSemaphoreTake(vagasMutex, portMAX_DELAY) == pdTRUE) {
        JsonArray arr = doc["vagas"];
        for (int i = 0; i < arr.size() && i < TOTAL_VAGAS; i++) {
          vagas[i].ocupada = arr[i]["ocupada"];
          vagas[i].reservada = arr[i]["reservada"];
        }
        atualizarContagemVagas();
        controlarLEDs();
        xSemaphoreGive(vagasMutex);
        Serial.println("Estado restaurado com sucesso!");
      }
    }
  } else {
    Serial.println("Nenhum backup encontrado ou Firebase indisponível.");
  }
}

// =================================================================
// FUNÇÃO SETUP PRINCIPAL
// =================================================================
void setup() {
  Serial.begin(115200);

  // --- Inicialização do Hardware ---
  for (int i = 0; i < TOTAL_CATRACAS; i++) {
    catracas[i].servo.attach(catracas[i].pinoServo);
    catracas[i].servo.write(0);
  }
  for (int i = 0; i < TOTAL_VAGAS; i++) {
    pinMode(vagas[i].pinoSensor, INPUT_PULLUP);
    pinMode(vagas[i].pinoLedVermelho, OUTPUT);
    pinMode(vagas[i].pinoLedRgbG, OUTPUT);
    pinMode(vagas[i].pinoLedRgbB, OUTPUT);
  }

  // --- Inicialização de Rede e Serviços ---
  setup_wifi();
  client.setServer(mqtt_server, mqtt_port);
  client.setCallback(callback);
  setup_firebase();

  // --- Inicialização do FreeRTOS ---
  // Cria o mutex antes de criar as tarefas que irão usá-lo.
  vagasMutex = xSemaphoreCreateMutex();

  // Restaura o estado ANTES de iniciar as tarefas para evitar condições de corrida.
  restaurarEstadoDoFirebase();

  // --- Criação das Tarefas ---
  // Stack de 2048 bytes é geralmente suficiente para tarefas de I/O.
  // Prioridade 2 (maior) para garantir que a leitura dos sensores seja responsiva.
  // Fixada no Core 0, ideal para tarefas de hardware.
  xTaskCreatePinnedToCore(taskLerSensores, "LerSensores", 2048, NULL, 2, NULL, 0);
  xTaskCreatePinnedToCore(taskControleCatracas, "CtrlCatracas", 2048, NULL, 2, NULL, 0);

  // Stack de 4096 bytes é mais seguro para tarefas de rede (WiFi, MQTT, Firebase).
  // Prioridade 1 (menor) para não interferir com as tarefas de tempo real.
  // Fixada no Core 1, ideal para tarefas de comunicação.
  xTaskCreatePinnedToCore(taskMQTT, "TaskMQTT", 4096, NULL, 1, NULL, 1);

  Serial.println("Setup concluído. Sistema em operação ;).");
}

// =================================================================
// FUNÇÃO LOOP
// =================================================================
void loop() {
  // O loop principal do Arduino é desnecessário quando usamos o FreeRTOS para
  // gerenciar as tarefas. Deletamos a tarefa do loop para liberar recursos.
  vTaskDelete(NULL);
}